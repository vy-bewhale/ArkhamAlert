# Arkham Client (arkham_client)

Клиентская библиотека на Python для взаимодействия с API Arkham Intelligence и мониторинга транзакций в блокчейне. Позволяет легко настраивать фильтры и получать данные о транзакциях для анализа.

## Основные возможности

*   Простая инициализация с использованием API-ключа Arkham.
*   Гибкая настройка фильтров для транзакций (минимальная сумма в USD, временной период, адреса отправителя/получателя, токены и т.д.).
*   Автоматическое кеширование информации об адресах и токенах для оптимизации запросов.
*   Получение данных о транзакциях в виде DataFrame от Pandas для удобного анализа.
*   Методы для получения списков известных имен сущностей и символов токенов из кеша, для использования в фильтрах.
*   Фоновый мониторинг новых транзакций с использованием callback-функций.

## Установка

Вы можете установить библиотеку `arkham_client` несколькими способами:

**1. (Рекомендуется, если/когда будет опубликовано на PyPI):**
   ```bash
   pip install arkham_client
   ```

**2. Установка последней версии напрямую из GitHub:**
   ```bash
   pip install git+https://github.com/vy-bewhale/ArkhamAlert.git
   ```

**3. Для локальной разработки:**
   ```bash
   git clone https://github.com/vy-bewhale/ArkhamAlert.git
   cd ArkhamAlert
   pip install -e .
   ```

## Конфигурация

Для работы с API Arkham вам потребуется API-ключ. Библиотека ожидает, что ключ будет доступен как переменная окружения `ARKHAM_API_KEY`.

Рекомендуется создать файл `.env` в корне вашего проекта (где вы будете использовать эту библиотеку) со следующим содержимым:

```
ARKHAM_API_KEY="ВАШ_API_КЛЮЧ_ЗДЕСЬ"
# ARKHAM_API_BASE_URL="АЛЬТЕРНАТИВНЫЙ_URL_ЕСЛИ_НУЖНО" (опционально)
```

Библиотека использует `python-dotenv` для автоматической загрузки переменных из этого файла.

## Быстрый старт и Примеры использования

Вот базовый пример того, как использовать библиотеку, включая работу с кешем для фильтрации:

```python
import os
import pandas as pd
import time 
from dotenv import load_dotenv
from arkham.arkham_monitor import ArkhamMonitor

# --- 1. Инициализация ---
load_dotenv() 
API_KEY = os.getenv("ARKHAM_API_KEY")

if not API_KEY:
    raise ValueError("Необходимо установить переменную окружения ARKHAM_API_KEY или создать .env файл.")

monitor = ArkhamMonitor(api_key=API_KEY)

# --- 2. Инициализация/наполнение кеша ---
# Это важный шаг, если вы планируете использовать фильтры по именам сущностей или символам токенов.
print("Инициализация кеша...")
if monitor.initialize_cache(lookback='6h', usd_gte=500000, limit=50): # Запрашиваем недавние крупные транзакции для наполнения кеша
    print(f"Кеш успешно инициализирован.")
else:
    print("Ошибка при инициализации кеша.")

# --- 3. Получение известных имен и символов из кеша для использования в фильтрах ---
known_cex_names = [name for name in monitor.get_known_address_names() if "Cex" in name and "Binance" in name] # Пример: ищем Binance CEX
known_token_symbols = monitor.get_known_token_symbols() # Все известные символы

print(f"\nИзвестные имена CEX, содержащие 'Binance' (из кеша): {known_cex_names}")
if 'USDT' in known_token_symbols and 'USDC' in known_token_symbols:
    print("Символы USDT и USDC присутствуют в кеше.")
    target_tokens = ['USDT', 'USDC']
else:
    print("USDT или USDC не найдены в кеше, фильтр по ним может быть неэффективен. Будут использованы все доступные токены.")
    target_tokens = None # Или пустой список, в зависимости от желаемого поведения

# --- 4. Установка фильтров с использованием данных из кеша ---
print("\nУстановка фильтров...")
if known_cex_names and target_tokens:
    monitor.set_filters(
        min_usd=100000, 
        lookback='1h', 
        token_symbols=target_tokens, # Используем символы, проверенные на наличие в кеше
        to_address_names=known_cex_names # Используем имена, полученные из кеша
    )
    print(f"Фильтры установлены: >100k USD, за 1 час, токены: {target_tokens}, на адреса: {known_cex_names}")
else:
    monitor.set_filters(min_usd=100000, lookback='1h') # Общий фильтр, если нужные имена/токены не найдены
    print("Фильтры установлены: >100k USD, за 1 час (специфичные CEX/токены не найдены в кеше для фильтрации)")


# --- 5. Получение транзакций ---
print("\nПолучение транзакций по фильтрам...")
df_transactions = monitor.get_transactions(limit=5) 

if not df_transactions.empty:
    print(f"Найдено {len(df_transactions)} транзакций:")
    print(df_transactions.head())
else:
    print("Транзакции по заданным фильтрам не найдены.")

# --- 6. Пример фонового мониторинга ---
def my_transaction_callback(tx_data: dict):
    print(f"\n[CALLBACK] Новая транзакция: {tx_data.get('USD')} USD, {tx_data.get('Символ')}")
    print(f"    От: {tx_data.get('Откуда')}, Кому: {tx_data.get('Куда')}")

print("\nЗапуск фонового мониторинга на 25 секунд (интервал 10 сек)...")
monitor.set_filters(min_usd=10000, lookback='10m', token_symbols=['ETH', 'WETH']) 
monitor.start_background_monitoring(interval_seconds=10, callback=my_transaction_callback)

try:
    time.sleep(25) 
except KeyboardInterrupt:
    print("\nПрервано пользователем.")
finally:
    monitor.stop_background_monitoring()
    print("Фоновый мониторинг завершен.")

# Вы можете найти больше примеров в папке /examples вашего репозитория.
```

---

## Детальное описание API (Внешний интерфейс `ArkhamMonitor`)

Этот раздел предоставляет подробную информацию о публичном API класса `ArkhamMonitor`.

**Важно при работе с фильтрами:** Эффективность фильтрации по именам сущностей (`from_address_names`, `to_address_names`) и символам токенов (`token_symbols`) напрямую зависит от полноты внутреннего кеша библиотеки. Перед использованием этих параметров в `set_filters()`, рекомендуется:
1.  Выполнить `initialize_cache()` для первоначального наполнения кеша.
2.  Получить актуальные списки доступных для фильтрации имен и символов с помощью методов `get_known_address_names()` и `get_known_token_symbols()`.
3.  Использовать в `set_filters()` только те имена и символы, которые присутствуют в кеше. Передача произвольных строк, отсутствующих в кеше, приведет к тому, что фильтрация по ним на стороне API Arkham не будет применена.

### Класс `ArkhamMonitor`

Основной класс для взаимодействия с API Arkham и управления данными о транзакциях.

**Импорт:**
```python
from arkham.arkham_monitor import ArkhamMonitor
```

#### Конструктор

**`__init__(self, api_key: str | None = None, api_base_url: str | None = None, ...)`** 
(Остальные параметры `address_cache` и т.д. предназначены для продвинутой кастомизации и обычно создаются автоматически)

Инициализирует монитор.

*   **Параметры:**
    *   `api_key` (`str`, опционально): Ваш API-ключ Arkham. Если не предоставлен, будет предпринята попытка загрузить его из переменной окружения `ARKHAM_API_KEY`. **Это основной обязательный параметр для аутентификации.**
    *   `api_base_url` (`str`, опционально): Базовый URL для API Arkham. По умолчанию используется стандартный URL или значение из переменной окружения `ARKHAM_API_BASE_URL`.
*   **Выбрасывает (Raises):**
    *   `ValueError`: Если `api_key` не предоставлен и не найден в переменных окружения.

#### Методы

**`initialize_cache(self, lookback: str = '1d', usd_gte: float = 100000, limit: int = 100) -> bool`**

Выполняет первоначальный запрос к API для наполнения внутренних кешей адресов и токенов. Рекомендуется вызывать для эффективной работы фильтров по именам/символам.

*   **Параметры:**
    *   `lookback` (`str`, опционально): Период времени для запроса (например, `'1h'`, `'7d'`). По умолчанию: `'1d'`.
    *   `usd_gte` (`float`, опционально): Минимальная сумма транзакции в USD. По умолчанию: `100000`.
    *   `limit` (`int`, опционально): Максимальное количество транзакций от API. По умолчанию: `100`.
*   **Возвращает:**
    *   `bool`: `True` при успехе, `False` при ошибке.

**`set_filters(self, min_usd: float | None = None, lookback: str | None = None, token_symbols: list[str] | None = None, from_address_names: list[str] | None = None, to_address_names: list[str] | None = None)`**

Устанавливает критерии фильтрации для запросов транзакций.

*   **Параметры:**
    *   `min_usd` (`float`, опционально): Минимальная стоимость транзакции в USD.
    *   `lookback` (`str`, опционально): Временной диапазон (например, `'24h'`).
    *   `token_symbols` (`list[str]`, опционально): Список символов токенов. **Используйте значения, полученные из `get_known_token_symbols()` или убедитесь, что они есть в кеше.** Если символы (или их ID) не найдены в кеше, фильтр по ним на стороне API не будет применен.
    *   `from_address_names` (`list[str]`, опционально): Список имен/адресов отправителей. **Используйте значения, полученные из `get_known_address_names()` или убедитесь, что они есть в кеше.** Если имена (или их ID) не найдены в кеше, фильтр по ним на стороне API не будет применен.
    *   `to_address_names` (`list[str]`, опционально): Список имен/адресов получателей. **Аналогично `from_address_names`, эффективность зависит от кеша.**
*   **Возвращает:**
    *   `None`

**`get_transactions(self, limit: int = 100) -> pd.DataFrame`**

Запрашивает транзакции у API Arkham на основе текущих фильтров.

*   **Параметры:**
    *   `limit` (`int`, опционально): Максимальное количество транзакций от API. По умолчанию: `100`.
*   **Возвращает:**
    *   `pd.DataFrame`: DataFrame с транзакциями. Колонки:
        *   `"Время"` (`str`): Время транзакции UTC (например, "YYYY-MM-DD HH:MM:SS").
        *   `"Сеть"` (`str`): Блокчейн-сеть.
        *   `"Откуда"` (`str`): Имя/адрес отправителя.
        *   `"Куда"` (`str`): Имя/адрес получателя.
        *   `"Символ"` (`str`): Символ токена.
        *   `"Кол-во"` (`str`): Количество токена (строка для точности).
        *   `"USD"` (`str`): Стоимость в USD (строка для точности).
        Возвращает пустой DataFrame при отсутствии данных или ошибке.

**`get_known_address_names(self) -> list[str]`**

Возвращает отсортированный список уникальных "реальных" имен адресов/сущностей из кеша. **Эти значения можно использовать в параметрах `from_address_names` и `to_address_names` метода `set_filters()`.**

*   **Возвращает:**
    *   `list[str]`: Список имен.

**`get_known_token_symbols(self) -> list[str]`**

Возвращает отсортированный список уникальных символов токенов из кеша, для которых есть известные ID. **Эти значения можно использовать в параметре `token_symbols` метода `set_filters()`.**

*   **Возвращает:**
    *   `list[str]`: Список символов.

**`get_token_symbol_map(self) -> dict[str, set[str]]`**

Возвращает словарь: символ токена (UPPERCASE) -> множество его известных ID (адресов контрактов). Может быть полезно для понимания, какие ID стоят за символами в кеше.

*   **Возвращает:**
    *   `dict[str, set[str]]`.

**`start_background_monitoring(self, interval_seconds: int = 60, callback: Callable[[dict], None] = lambda tx: print(...))`**

Запускает фоновый мониторинг новых транзакций по текущим фильтрам.

*   **Параметры:**
    *   `interval_seconds` (`int`, опционально): Интервал проверки (сек). По умолчанию: `60`.
    *   `callback` (`Callable[[dict], None]`, опционально): Функция, вызываемая для каждой новой транзакции. Принимает словарь `tx_data`.
        *   **Структура `tx_data`:** Словарь с ключами, аналогичными колонкам DataFrame из `get_transactions()` (`"Время"`, `"Сеть"`, `"Откуда"`, `"Куда"` , `"Символ"`, `"Кол-во"`, `"USD"`).
*   **Возвращает:**
    *   `None`

**`stop_background_monitoring(self, timeout: float = 5.0)`**

Останавливает фоновый мониторинг.

*   **Параметры:**
    *   `timeout` (`float`, опционально): Таймаут ожидания завершения (сек). По умолчанию: `5.0`.
*   **Возвращает:**
    *   `None`

### Пользовательские исключения

*   **`ArkhamAPIError(Exception)`**
    Может возникать при ошибках взаимодействия с API Arkham (неверный ключ, проблемы сервера Arkham и т.д.).

---

## Лицензия

Этот проект распространяется под лицензией MIT. Смотрите файл `LICENSE` для получения дополнительной информации.

## Внесение вклада (Contributing)

Предложения и пул-реквесты приветствуются! Для серьезных изменений, пожалуйста, сначала откройте issue для обсуждения того, что вы хотели бы изменить.

Пожалуйста, убедитесь, что тесты обновлены соответствующим образом. 