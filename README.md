# Arkham Client (arkham_client)

Клиентская библиотека на Python для взаимодействия с API Arkham Intelligence и мониторинга транзакций в блокчейне. Позволяет легко настраивать фильтры и получать данные о транзакциях для анализа.

## Основные возможности

*   Простая инициализация с использованием API-ключа Arkham.
*   Гибкая настройка фильтров для транзакций (минимальная сумма в USD, временной период, адреса отправителя/получателя, токены и т.д.).
*   Автоматическое кеширование информации об адресах и токенах для оптимизации запросов.
*   Получение данных о транзакциях в виде DataFrame от Pandas для удобного анализа.
*   Методы для получения списков известных имен сущностей и символов токенов из кеша, для использования в фильтрах.
*   Фоновый мониторинг новых транзакций с использованием callback-функций.

## Установка

Вы можете установить библиотеку `arkham_client` несколькими способами:

**1. (Рекомендуется, если/когда будет опубликовано на PyPI):**
   ```bash
   pip install arkham_client
   ```

**2. Установка последней версии напрямую из GitHub:**
   ```bash
   pip install git+https://github.com/vy-bewhale/arkham_client.git
   ```

**3. Для локальной разработки:**
   ```bash
   git clone https://github.com/vy-bewhale/arkham_client.git
   cd arkham_client
   pip install -e .
   ```

## Конфигурация

Для работы с API Arkham вам потребуется API-ключ. Библиотека ожидает, что ключ будет доступен как переменная окружения `ARKHAM_API_KEY`.

Рекомендуется создать файл `.env` в корне вашего проекта (где вы будете использовать эту библиотеку) со следующим содержимым:

```
ARKHAM_API_KEY="ВАШ_API_КЛЮЧ_ЗДЕСЬ"
# ARKHAM_API_BASE_URL="АЛЬТЕРНАТИВНЫЙ_URL_ЕСЛИ_НУЖНО" (опционально)
```

Библиотека использует `python-dotenv` для автоматической загрузки переменных из этого файла.

## Быстрый старт и Примеры использования

Вот базовый пример того, как использовать библиотеку, демонстрирующий основные сценарии работы, включая фильтрацию по CEX и DEX:

```python
import os
import pandas as pd
from dotenv import load_dotenv
from arkham.arkham_monitor import ArkhamMonitor

# --- 1. Инициализация ---
load_dotenv()
API_KEY = os.getenv("ARKHAM_API_KEY")

if not API_KEY:
    raise ValueError("Необходимо установить переменную окружения ARKHAM_API_KEY или создать .env файл.")

monitor = ArkhamMonitor(api_key=API_KEY)

# --- 2. Наполнение кеша ---
# Первоначальный запрос для получения данных и наполнения кешей адресов/токенов.
# Используем широкие фильтры (например, 5M USD, за последние 24 часа), запрашиваем до 1000 транзакций.
# Это важный шаг для эффективной работы последующих фильтров по именам/символам.
print("Этап 2: Наполнение кеша транзакциями (5M USD, 24ч, до 1000)...")
monitor.set_filters(min_usd=5000000, lookback='24h')
initial_df = monitor.get_transactions(limit=1000)
if not initial_df.empty:
    print(f"  Найдено {len(initial_df)} транзакций для наполнения кеша.")
    # print(initial_df.head()) # Раскомментируйте, чтобы посмотреть транзакции
else:
    print("  Не найдено транзакций для первоначального наполнения кеша.")

# --- 3. Получение списков имен из кеша ---
# Эти имена можно использовать для более точной фильтрации
all_known_names = monitor.get_known_address_names() # Используем метод ArkhamMonitor
if all_known_names:
    print(f"\nЭтап 3: Из кеша загружено {len(all_known_names)} уникальных имен/адресов.")
    # print(f"  Некоторые известные имена (первые 5): {all_known_names[:5]}") # Раскомментируйте для просмотра
else:
    print("\nЭтап 3: Кеш имен пуст. Возможно, первоначальный запрос не вернул транзакций.")

# --- 4. Демонстрация фильтра "В CEX" ---
print("\nЭтап 4: Демонстрация фильтра 'В CEX'")
# Находим все имена сущностей из кеша, содержащие "Cex"
cex_names = [name for name in all_known_names if "Cex" in name]
# Выбираем целевые токены (убедитесь, что они есть в кеше через monitor.get_known_token_symbols() для лучшей фильтрации)
target_tokens_cex = ['BTC', 'USDT', 'USDC'] 
print(f"  Используем найденные CEX имена (пример): {cex_names[:3] if cex_names else 'Нет CEX имен в кеше'}")
print(f"  Используем целевые токены: {target_tokens_cex}")

if cex_names:
    # Устанавливаем фильтры: куда = найденные Cex, токены = BTC/USDT/USDC, 5M USD, 24ч
    monitor.set_filters(
        min_usd=5000000,
        lookback='24h',
        token_symbols=target_tokens_cex,
        to_address_names=cex_names
    )
    # Получаем отфильтрованные транзакции (до 100)
    df_to_cex = monitor.get_transactions(limit=100)
    if not df_to_cex.empty:
        print(f"  Найдено транзакций 'В CEX': {len(df_to_cex)}")
        print(df_to_cex.head())
    else:
        print("  Транзакции 'В CEX' по заданным фильтрам не найдены.")
else:
    print("  Не найдено имен CEX в кеше для демонстрации фильтра 'В CEX'.")


# --- 5. Демонстрация фильтра "Из DEX" ---
print("\nЭтап 5: Демонстрация фильтра 'Из DEX'")
# Находим все имена сущностей из кеша, содержащие "Dex"
dex_names = [name for name in all_known_names if "Dex" in name]
print(f"  Используем найденные DEX имена (пример): {dex_names[:3] if dex_names else 'Нет DEX имен в кеше'}")

if dex_names:
    # Устанавливаем фильтры: откуда = найденные Dex, 5M USD, 24ч
    monitor.set_filters(
        min_usd=5000000,
        lookback='24h',
        from_address_names=dex_names
    )
    # Получаем отфильтрованные транзакции (до 100)
    df_from_dex = monitor.get_transactions(limit=100)
    if not df_from_dex.empty:
        print(f"  Найдено транзакций 'Из DEX': {len(df_from_dex)}")
        print(df_from_dex.head())
    else:
        print("  Транзакции 'Из DEX' по заданным фильтрам не найдены.")
else:
    print("  Не найдено имен DEX в кеше для демонстрации фильтра 'Из DEX'.")

print("\nПример завершен. Переменные df_to_cex и df_from_dex содержат результаты (если были найдены).")

# Вы можете найти этот и другие примеры в папке /examples вашего репозитория.
```

---

## Детальное описание API (Внешний интерфейс `ArkhamMonitor`)

Этот раздел предоставляет подробную информацию о публичном API класса `ArkhamMonitor`.

**Важно при работе с фильтрами:** Эффективность фильтрации по именам сущностей (`from_address_names`, `to_address_names`) и символам токенов (`token_symbols`) напрямую зависит от полноты внутреннего кеша библиотеки. Перед использованием этих параметров в `set_filters()`, рекомендуется:
1.  Выполнить `initialize_cache()` для первоначального наполнения кеша.
2.  Получить актуальные списки доступных для фильтрации имен и символов с помощью методов `get_known_address_names()` и `get_known_token_symbols()`.
3.  Использовать в `set_filters()` только те имена и символы, которые присутствуют в кеше. Передача произвольных строк, отсутствующих в кеше, приведет к тому, что фильтрация по ним на стороне API не будет применена.

### Класс `ArkhamMonitor`

Основной класс для взаимодействия с API Arkham и управления данными о транзакциях.

**Импорт:**
```python
from arkham.arkham_monitor import ArkhamMonitor
```

#### Конструктор

**`__init__(self, api_key: str | None = None, api_base_url: str | None = None, ...)`** 
(Остальные параметры `address_cache` и т.д. предназначены для продвинутой кастомизации и обычно создаются автоматически)

Инициализирует монитор.

*   **Параметры:**
    *   `api_key` (`str`, опционально): Ваш API-ключ Arkham. Если не предоставлен, будет предпринята попытка загрузить его из переменной окружения `ARKHAM_API_KEY`. **Это основной обязательный параметр для аутентификации.**
    *   `api_base_url` (`str`, опционально): Базовый URL для API Arkham. По умолчанию используется стандартный URL или значение из переменной окружения `ARKHAM_API_BASE_URL`.
*   **Выбрасывает (Raises):**
    *   `ValueError`: Если `api_key` не предоставлен и не найден в переменных окружения.

#### Методы

**`initialize_cache(self, lookback: str = '1d', usd_gte: float = 100000, limit: int = 100) -> bool`**

Выполняет первоначальный запрос к API для наполнения внутренних кешей адресов и токенов. Рекомендуется вызывать для эффективной работы фильтров по именам/символам.

*   **Параметры:**
    *   `lookback` (`str`, опционально): Период времени для запроса (например, `'1h'`, `'7d'`). По умолчанию: `'1d'`.
    *   `usd_gte` (`float`, опционально): Минимальная сумма транзакции в USD. По умолчанию: `100000`.
    *   `limit` (`int`, опционально): Максимальное количество транзакций от API. По умолчанию: `100`.
*   **Возвращает:**
    *   `bool`: `True` при успехе, `False` при ошибке.

**`set_filters(self, min_usd: float | None = None, lookback: str | None = None, token_symbols: list[str] | None = None, from_address_names: list[str] | None = None, to_address_names: list[str] | None = None)`**

Устанавливает критерии фильтрации для запросов транзакций.

*   **Параметры:**
    *   `min_usd` (`float`, опционально): Минимальная стоимость транзакции в USD.
    *   `lookback` (`str`, опционально): Временной диапазон (например, `'24h'`).
    *   `token_symbols` (`list[str]`, опционально): Список символов токенов. **Используйте значения, полученные из `get_known_token_symbols()` или убедитесь, что они есть в кеше.** Если символы (или их ID) не найдены в кеше, фильтр по ним на стороне API не будет применен.
    *   `from_address_names` (`list[str]`, опционально): Список имен/адресов отправителей. **Используйте значения, полученные из `get_known_address_names()` или убедитесь, что они есть в кеше.** Если имена (или их ID) не найдены в кеше, фильтр по ним на стороне API не будет применен.
    *   `to_address_names` (`list[str]`, опционально): Список имен/адресов получателей. **Аналогично `from_address_names`, эффективность зависит от кеша.**
*   **Возвращает:**
    *   `None`

**`get_transactions(self, limit: int = 100) -> pd.DataFrame`**

Запрашивает транзакции у API Arkham на основе текущих фильтров.

*   **Параметры:**
    *   `limit` (`int`, опционально): Максимальное количество транзакций от API. По умолчанию: `100`.
*   **Возвращает:**
    *   `pd.DataFrame`: DataFrame с транзакциями. Колонки:
        *   `"Время"` (`str`): Время транзакции UTC (например, "YYYY-MM-DD HH:MM:SS").
        *   `"Сеть"` (`str`): Блокчейн-сеть.
        *   `"Откуда"` (`str`): Имя/адрес отправителя.
        *   `"Куда"` (`str`): Имя/адрес получателя.
        *   `"Символ"` (`str`): Символ токена.
        *   `"Кол-во"` (`str`): Количество токена (строка для точности).
        *   `"USD"` (`str`): Стоимость в USD (строка для точности).
        *   `"TxID"` (`str`): Хеш транзакции. Содержит официальный хеш (`txid`/`transactionHash`) из API, если он доступен. Если официальный хеш отсутствует, содержит сгенерированный библиотекой идентификатор с префиксом `arkham_client_generated:`. Может содержать 'N/A' в редких случаях ошибки генерации.
        Возвращает пустой DataFrame при отсутствии данных или ошибке.

**`get_known_address_names(self) -> list[str]`**

Возвращает отсортированный список уникальных "реальных" имен адресов/сущностей из кеша. **Эти значения можно использовать в параметрах `from_address_names` и `to_address_names` метода `set_filters()`.**

*   **Возвращает:**
    *   `list[str]`: Список имен.

**`get_known_token_symbols(self) -> list[str]`**

Возвращает отсортированный список уникальных символов токенов из кеша, для которых есть известные ID. **Эти значения можно использовать в параметре `token_symbols` метода `set_filters()`.**

*   **Возвращает:**
    *   `list[str]`: Список символов.

**`get_token_symbol_map(self) -> dict[str, set[str]]`**

Возвращает словарь: символ токена (UPPERCASE) -> множество его известных ID (адресов контрактов). Может быть полезно для понимания, какие ID стоят за символами в кеше.

*   **Возвращает:**
    *   `dict[str, set[str]]`.

**`start_background_monitoring(self, interval_seconds: int = 60, callback: Callable[[dict], None] = lambda tx: print(...))`**

Запускает фоновый мониторинг новых транзакций по текущим фильтрам.

*   **Параметры:**
    *   `interval_seconds` (`int`, опционально): Интервал проверки (сек). По умолчанию: `60`.
    *   `callback` (`Callable[[dict], None]`, опционально): Функция, вызываемая для каждой новой транзакции. Принимает словарь `tx_data`.
        *   **Структура `tx_data`:** Словарь с ключами, аналогичными колонкам DataFrame из `get_transactions()` (`"Время"`, `"Сеть"`, `"Откуда"`, `"Куда"` , `"Символ"`, `"Кол-во"`, `"USD"`). 
        *   Также содержит внутренние поля, включая `"_txid"` (хеш транзакции - официальный или сгенерированный), `"_from_identifier"`, `"_to_identifier"`, `"_token_id"`, `"USD_numeric"` и `"_raw_data"` (исходные данные транзакции от API).
*   **Возвращает:**
    *   `None`

**`stop_background_monitoring(self, timeout: float = 5.0)`**

Останавливает фоновый мониторинг.

*   **Параметры:**
    *   `timeout` (`float`, опционально): Таймаут ожидания завершения (сек). По умолчанию: `5.0`.
*   **Возвращает:**
    *   `None`

## Управление состоянием кеша (Сериализация)

Библиотека предоставляет возможность сохранять и загружать состояние внутренних кешей (`AddressCache` и `TokenCache`). Это может быть полезно для восстановления сессий в веб-приложениях или для сохранения состояния между запусками скриптов, чтобы избежать повторного наполнения кеша с нуля.

В классах `AddressCache` и `TokenCache` для этого реализованы методы `get_state() -> dict` и `load_state(state: dict)`.

Для удобства, в основном классе `ArkhamMonitor` добавлены следующие методы-обертки:

**`get_full_cache_state(self) -> dict`**

Возвращает сериализуемое состояние всех кешей (`AddressCache` и `TokenCache`) в виде словаря. Этот словарь можно затем сохранить (например, в формате JSON).

*   **Возвращает:**
    *   `dict`: Словарь, содержащий состояния кешей, например:
        ```python
        {
            'address_cache': { ... состояние AddressCache ... },
            'token_cache': { ... состояние TokenCache ... }
        }
        ```
    *   Возвращает пустой словарь в случае ошибки или если кеши не инициализированы.

**`load_full_cache_state(self, full_state: dict | None)`**

Загружает состояние всех кешей из ранее сохраненного словаря. Это перезапишет текущее содержимое кешей.

*   **Параметры:**
    *   `full_state` (`dict | None`): Словарь, содержащий состояния `'address_cache'` и `'token_cache'`, полученный ранее с помощью `get_full_cache_state()`. Если `None` или пустой, кеши не будут изменены.
*   **Возвращает:**
    *   `None`

### Пример сохранения и загрузки состояния кеша

```python
import os
from dotenv import load_dotenv
from arkham.arkham_monitor import ArkhamMonitor
# import json # Для сохранения в файл (опционально)

# --- 1. Инициализация и первоначальное наполнение кеша ---
load_dotenv()
API_KEY = os.getenv("ARKHAM_API_KEY")
monitor1 = ArkhamMonitor(api_key=API_KEY)

print("Наполняем кеш в первом экземпляре монитора...")
# Пример: выполняем несколько запросов для наполнения кеша
# В реальном приложении это может быть результатом работы пользователя
monitor1.set_filters(min_usd=1000000, lookback='1h')
monitor1.get_transactions(limit=50) # Первый запрос
monitor1.set_filters(min_usd=500000, lookback='6h', token_symbols=['BTC'])
monitor1.get_transactions(limit=50) # Второй запрос

known_addresses_m1 = monitor1.get_known_address_names()
known_tokens_m1 = monitor1.get_known_token_symbols()
print(f"Имен в кеше адресов (monitor1): {len(known_addresses_m1)}")
print(f"Символов в кеше токенов (monitor1): {len(known_tokens_m1)}")
# if known_addresses_m1: print(f"  Пример имен: {known_addresses_m1[:3]}")

# --- 2. Сохранение состояния кеша ---
print("\nСохраняем состояние кешей...")
cache_state_to_save = monitor1.get_full_cache_state()

# Опционально: сохранение в JSON файл
# file_path = 'arkham_cache_state.json'
# with open(file_path, 'w', encoding='utf-8') as f:
#     json.dump(cache_state_to_save, f, ensure_ascii=False, indent=4)
# print(f"Состояние кешей сохранено в {file_path} (симуляция).")

# --- 3. Создание нового экземпляра монитора и загрузка состояния ---
print("\nСоздаем второй экземпляр монитора (monitor2)...")
monitor2 = ArkhamMonitor(api_key=API_KEY) # Новый, кеши пустые

print(f"Имен в кеше адресов (monitor2 до загрузки): {len(monitor2.get_known_address_names())}")
print(f"Символов в кеше токенов (monitor2 до загрузки): {len(monitor2.get_known_token_symbols())}")

print("Загружаем сохраненное состояние в monitor2...")
monitor2.load_full_cache_state(cache_state_to_save)
# Если сохраняли в файл:
# with open(file_path, 'r', encoding='utf-8') as f:
#     loaded_state_from_file = json.load(f)
# monitor2.load_full_cache_state(loaded_state_from_file)

print("Состояние кешей загружено в monitor2.")

# --- 4. Проверка восстановленного кеша ---
known_addresses_m2 = monitor2.get_known_address_names()
known_tokens_m2 = monitor2.get_known_token_symbols()
print(f"Имен в кеше адресов (monitor2 после загрузки): {len(known_addresses_m2)}")
print(f"Символов в кеше токенов (monitor2 после загрузки): {len(known_tokens_m2)}")

# Проверяем, что количество элементов совпадает
assert len(known_addresses_m1) == len(known_addresses_m2), "Количество имен адресов не совпадает"
assert len(known_tokens_m1) == len(known_tokens_m2), "Количество символов токенов не совпадает"

# Опционально, более глубокая проверка, если нужно (например, сравнение самих списков)
# assert sorted(known_addresses_m1) == sorted(known_addresses_m2)

print("Проверка: кеш успешно восстановлен.")
```

Этот функционал позволяет эффективно управлять состоянием кеша, что особенно важно для приложений, требующих персистентности данных между сессиями или запусками.

### Пользовательские исключения

*   **`ArkhamAPIError(Exception)`**
    Может возникать при ошибках взаимодействия с API Arkham (неверный ключ, проблемы сервера Arkham и т.д.).

---

## Лицензия

Этот проект распространяется под лицензией MIT. Смотрите файл `LICENSE` для получения дополнительной информации.

## Внесение вклада (Contributing)

Предложения и пул-реквесты приветствуются! Для серьезных изменений, пожалуйста, сначала откройте issue для обсуждения того, что вы хотели бы изменить.

Пожалуйста, убедитесь, что тесты обновлены соответствующим образом. 